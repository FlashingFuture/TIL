N = int(input())
DIV_NUM = int(1e9)
# 풀이에 대한 고민(직접 해결 실패)
# N개의 자리에 대해 (N <= 100) 옆 자리들과의 차이가 1인 수의 총 가짓수
# DP로 풀 경우 크기 100짜리 DP를 만들게 되므로
# 여러 개의 DP를 만들어도 여유있을 것
# 이 문제의 경우 0, 9의 경우 다음 수가 확정(1, 8)이고
# 다른 경우 두 갈래(+1, -1)로 갈 수 있으므로
# 이를 이용해 DP를 작성하면 될 것
# 하지만 0~9까지 모든 수가 등장해야 한다는 조건은 이렇게 풀면 해결 불능
# 전체 경우가 10^100이므로, 전체에 대해 순회하면 시간 초과가 날 것
# DP를 하면서 가지치기를 할 수 있을까
# 1~9의 출발점에 대해, count 와 위치를 저장해주면서 가서
# 끝까지 도달한 경우 count 를 확인해 0~9가 다 나온 경우 더해주는 로직을 짜면
# 2^100 * 10 정도 나와서 시간초과가 날 것 같다
# 결국 풀이를 찾아보았다(비트필드를 이용한 DP 개념 검색)
# DP를 사용하되, 배열을 3차원으로 선언하여 방문했는지 안했는지를
# 10비트짜리 비트필드를 dp로 나누어 저장해줌으로써 시간 제한 내에 풀이할 수 있다
# 이 경우 최대 시간복잡도는 100 * 10 * 2^10(1000) = 1000000
DP = [[[0] * (1 << 10) for _ in range(10)] for __ in range(N)]
for i in range(1, 10):  # 첫 자릿수 저장
    print(1 << i)
    DP[0][i][1 << i] = 1

for i in range(1, N):
    # 0에 대한 dp
    for k in range(1 << 10 - 1):
        if DP[i - 1][1][k]:
            DP[i][0][k | (1 << 0)] = DP[i - 1][8][k]
    # 9에 대한 dp
    for k in range(1 << 10 - 1):
        if DP[i - 1][8][k]:
            DP[i][9][k | (1 << 9)] = DP[i - 1][8][k]
    # 1~8에 대한 dp
    for j in range(1, 9):
        for k in range(1 << 10 - 1):
            DP[i][j][k | (1 << j)] = DP[i - 1][j - 1][k] + DP[i - 1][j + 1][k]

res = 0
for i in range(10):
    for k in range(1024):
        if DP[N - 1][i][k]:
            print(k)

print(res % DIV_NUM)