## 063. 소프트웨어 아키텍쳐
### Software Architecture
소프트웨어 아키텍처 : 소프트웨어 구성 요소들 간 관계를 표현하는 시스템의 구조 또는 구조체

### Modularity
모듈화 : 시스템의 기능을 모듈 단위로 나누는 것

### Abstraction
추상화 : 문제의 전체적이고 포괄적인 개념을 설계한 후 세분화하여 구체화시켜 나가는 것

## 064. 아키텍처 패턴
### Pipe-Filter Pattern
파이프-필터 패턴 : 데이터 스트림의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴

### Model-View-Controller Pattern
MVC 패턴 : 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴

### Master-Slave Pattern
마스터-슬레이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴

## 065. 객체지향
### Object-Oriented
객체지향 : 소프트웨어의 각 요소들을 객체로 만들고, 객체들을 조립하여 소프트웨어를 개발하는 기법
- 클래스 : 공통된 속성과 연산을 갖는 객체의 집합
- 캡슐화(Encapsulation) : 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것

## 066. 객체지향 분석 및 설계
### Object Oriented Analysis
객체지향 분석(OOA) : 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업

### Rumbaugh
럼바우 분석 기법 : 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
- 객체 모델링 : 시스템 요구 객체를 찾고 관계를 규정하여 객체 다이어그램으로 표시하는 것
- 동적 모델링 : 상태 다이어그램을 이용하여 제어 흐름, 상호작용, 동적 순서 등 동적 행위를 표현하는 모델링
- 기능 모델링 : 자료 흐름도를 이용하여 프로세스 간 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체지향 설계 원칙
객체지향 설계 원칙 : 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙
- 단일 책임 원칙(SRP) : 객체는 단 하나의 책임만 가져야 함
- 개방-폐쇄 원칙(OCP) : 기존의 코드를 변경하지 말고 기능을 추가할 수 있도록 설계해야 함
- 리스코프 치환 원칙(LSP) : 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 함
- 인터페이스 분리 원칙(ISP) : 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 않아야 함
- 의존 역전 원칙(DIP) : 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 함

## 067. 모듈
### Module
모듈 : 모듈화를 통해 분리된 시스템의 각 기능

### Coupling
결합도 : 모듈 간 상호 의존하는 정도
- 내용(Content) 결합도 : 다른 모듈의 내부 기능 / 내부 자료를 직접 참조하거나 수정할 때의 결합도
- 공통(Common) 결합도 : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
- 외부(External) 결합도 : 모듈의 변수를 외부의 다른 모듈에서 참조할 때의 결합도
- 제어(Control) 결합도 : 다른 모듈의 논리 흐름을 제어하기 위해 제어 신호 / 요소를 전달하는 결합도
- 스탬프(Stamp) 결합도 : 모듈 간 인터페이스에 배열 / 레코드 등 자료 구조가 전달될 때의 결합도
- 자료(Data) 결합도 : 모듈 간 인터페이스가 자료 요소로만 구성될 때의 결합도

### Cohesion
응집도 : 모듈의 내부 요소들이 서로 관련되어 있는 정도
- 기능적(Functional) 응집도 : 모든 기능 요소가 단일 문제와 연관되어 수행될 경우의 응집도
- 순차적(Sequential) 응집도 : 모듈 내 활동의 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
- 교환적(Communication) 응집도 : 동일한 입출력을 사용해 서로 다른 기능을 수행하는 구성 요소가 모였을 경우의 응집도
- 절차적(Procedural) 응집도 : 모듈이 다수의 관련 기능을 가질 때 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- 시간적(Temporal) 응집도 : 특정 시간에 처리되는 기능을 모아 하나의 모듈로 작성할 경우의 응집도
- 논리적(Logical) 응집도 : 유사한 성격 / 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
- 우연적(Coincidental) 응집도 : 서로 관련 없는 요소로만 구성된 경우의 응집도

### Fan-In / Fan-Out
- 팬 인 : 어떤 모듈을 제어하는 모듈의 수
- 팬 아웃 : 어떤 모듈에 의해 제어되는 모듈의 수

## 068. 단위 모듈
### Inter-Process Communication
IPC : 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
- 대표 메서드 : Shared Memory, Socket, Semaphores, Pipes&named Pipes, Message Queueing

### Test Case
테스트 케이스 : 소프트웨어가 사용자 요구사항을 준수했는지 확인하기 위한 테스트 항목에 대한 명세서
- 구성 요소 : 식별자, 테스트항목, 입력 명세, 출력 명세, 환경설정, 특수 절차 요구, 의존성 기술

### 효과적인 모듈 설계
- 결합도를 줄이고 응집도를 높여 모듈의 독립성과 재사용성을 높임
- 복잡도와 중복성을 줄이고 일관성을 유지시킴

## 070. 코드
코드 : 자료의 분류 / 조합 / 집계 / 추출을 용ㅇ이하게 하는 기호
- 순차 코드, 블록 코드,  표의 숫자 코드 등

## 071. 디자인 패턴
### Design Pattern
디자인 패턴 : 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

### Creational Pattern
생성 패턴 : 클래스나 객체의 생성과 참조 과정을 정의하는 패턴
- 추상 팩토리 : 클래스에 의존하지 않고 인터페이스를 통해 서로 연관 / 의존하는 객체들의 그룹으로 추상적으로 표현
  - 연관된 서브 클래스를 묶어 한 번에 교체 가능
- 빌더 : 작게 분리된 인스턴스를 조합하여 객체를 생성
- 팩토리 메서드 : 객체 생성을 서브 클래스에서 처리하도록 캡슐화한 패턴
  - 상위 클래스에선 인터페이스만 정의하고 서브클래스가 실제 생성을 담당하는 패턴으로 가상 생성자 패턴이라고도 함
- 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤 : 하나의 객체를 하나의 프로세스만 참조할 수 있도록 하여 클래스 내 인스턴스가 하나뿐임을 보장함

### Structural Pattern
구조 패턴 : 클래스나 객체들을 조합해 더 큰 구조로 만드는 패턴
- 어댑터 : 호환성이 없는 클래스의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지 : 구현부에서 추상층을 분리해 서로가 독립적으로 확장될 수 있도록 구성한 패턴
  - 기능과 구현을 두 개의 별도 클래스로 둠
- 프록시 : 접근이 어려운 객체와 이에 연결하려는 객체 사이의 인터페이스 역할을 수행하는 패턴

### Behavioral Pattern
행위 패턴 : 클래스나 객체가 서로 상호작용 / 책임 분배의 방법을 정의하는 패턴
- 커맨드 : 요청을 객체의 형태로 캡슐화하여 재이용 / 취소 를 가능하도록 로그에 남기는 패턴
- 옵서버 : 한 객체의 상태가 변하면 상속된 다른 객체들에 변화된 상태를 전달하는 패턴
- 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략 : 동일한 계열 알고리즘들을 개별적 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 템플릿 메서드 : 상위 클래스에서 골격을 정의하고 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 방문자 : 각 클래스의 데이터 처리 기능을 분리하여 별도 클래스로 구성하는 패턴